# 스케줄러 구현

토키오 블러그의 "Making the Tokio scheculer 10x faster" 자료입니다. DeepL로 번역한 후 다듬고 이해한 내용을 추가합니다. 여러 페이지로 나눕니다.&#x20;

## 개요

저희는 Rust의 비동기 런타임인 Tokio의 다음 주요 개정판을 열심히 작업하고 있습니다. 오늘, 스케줄러의 완전한 재작성이 풀 리퀘스트로 제출되었습니다. 그 결과 성능과 지연 시간이 크게 개선되었습니다. 일부 벤치마크에서는 속도가 10배 빨라졌습니다! 이러한 종류의 개선이 "풀 스택" 사용 사례에 얼마나 영향을 미치는지는 항상 불분명하기 때문에 이러한 스케줄러 개선이 Hyper 및 토닉과 같은 사용 사례에 어떤 영향을 미치는지도 테스트했습니다(스포일러: 정말 좋습니다).

새 스케줄러 작업을 준비하면서 저는 스케줄러 구현에 관한 리소스를 검색하는 데 시간을 보냈습니다. 기존 구현 외에는 별다른 것을 찾지 못했습니다. 또한 기존 구현의 소스를 탐색하기가 어려웠습니다. 이 문제를 해결하기 위해 저는 Tokio의 새로운 스케줄러 구현을 최대한 깔끔하게 유지하려고 노력했습니다. 또한 비슷한 처지에 있는 다른 사람들이 유용하게 사용할 수 있기를 바라는 마음으로 스케줄러 구현에 대한 자세한 글을 작성하고 있습니다.

이 글은 작업 훔치기 스케줄러(work stealing scheduler)를 포함한 스케줄러 설계에 대한 개괄적인 개요로 시작합니다. 그런 다음 새로운 Tokio 스케줄러에서 이루어진 특정 최적화에 대해 자세히 설명합니다.

다루는 최적화는 다음과 같습니다:

* 새로운 std::future 작업 시스템&#x20;
* 더 나은 큐 알고리즘 선택하기&#x20;
* 메시지 전달 패턴 최적화&#x20;
* 스로틀(throttle) 훔치기&#x20;
* 교차 스레드 동기화 줄이기&#x20;
* 할당 감소&#x20;
* 원자 참조 카운팅 (atomic reference counting) 줄이기

주요 테마는 "축소"입니다. 결국, 코드가 없는 것보다 빠른 코드는 없습니다!

이 글에서는 새로운 스케줄러를 테스트하는 방법도 다룹니다. 정확하고 동시적이며 잠금 없는 코드를 작성하는 것은 정말 어렵습니다. 특히 메모리 안전과 관련된 버그라면 빠르고 버그가 많은 것보다 느리고 정확한 것이 낫습니다. 하지만 가장 좋은 방법은 빠르고 정확한 것이므로 동시성 테스트를 위한 도구인 loom을 만들었습니다.

