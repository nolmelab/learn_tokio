# Scheduler, how do they work?

스케줄러의 역할은 작업을 예약하는 것입니다. 애플리케이션은 작업 단위로 나뉘며, 이를 작업이라고 부릅니다. 작업은 진행이 가능할 때 실행 가능하며, 외부 리소스에서 차단되면 더 이상 실행할 수 없는(또는 유휴 상태인) 상태가 됩니다. 태스크는 실행 가능한 태스크의 수에 관계없이 동시에 실행할 수 있다는 점에서 독립적입니다. 스케줄러는 작업이 다시 유휴 상태로 전환될 때까지 실행 중인 상태의 작업을 실행할 책임이 있습니다. 태스크를 실행한다는 것은 글로벌 리소스인 CPU 시간을 태스크에 할당한다는 의미입니다.

이 문서에서는 사용자 공간 스케줄러, 즉 운영 체제 스레드 위에서 실행되는 스케줄러(커널 랜드 스케줄러에 의해 구동됨)에 대해 설명합니다. Tokio 스케줄러는 "비동기 녹색 스레드"로 생각할 수 있는 Rust 퓨처를 실행합니다. 이것은 많은 사용자 랜딩 작업이 몇 개의 운영 체제 스레드에 다중화되는 M:N 스레딩 패턴입니다.

스케줄러를 모델링하는 방법에는 여러 가지가 있으며, 각 방법에는 장단점이 있습니다. 가장 기본적인 수준에서 스케줄러는 실행 대기열과 대기열을 비우는 프로세서로 모델링할 수 있습니다. 프로세서는 스레드에서 실행되는 코드 조각입니다. 의사 코드로는 다음처럼 동작합니다:

```rust
while let Some(task) = self.queue.pop() {
    task.run();
}
```

작업을 실행할 수 있게 되면 실행 대기열에 삽입됩니다.

<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

리소스, 작업, 프로세서가 모두 단일 스레드에 존재하는 시스템을 설계할 수도 있지만, Tokio는 다중 스레드를 사용하기로 선택했습니다. 우리는 컴퓨터에 많은 CPU가 탑재된 세상에 살고 있습니다. 단일 스레드 스케줄러를 설계하면 하드웨어 활용도가 떨어질 수 있습니다. 우리는 모든 CPU를 사용하고 싶습니다. 이를 위한 몇 가지 방법이 있습니다:

* 하나의 글로벌 실행 대기열, 많은 프로세서.&#x20;
* 각각 고유한 실행 대기열을 가진 많은 프로세서.
