# Many processors, each with their own run queue (여러 프로세스들, 각각의 실행 큐)

스케줄러를 모델링하는 또 다른 방법은 여러 개의 단일 스레드 스케줄러를 사용하는 것입니다. 각 프로세서는 자체 실행 대기열을 가지며 작업은 특정 프로세서에 고정됩니다. 이렇게 하면 동기화 문제를 완전히 피할 수 있습니다. Rust의 작업 모델에는 모든 스레드에서 작업을 대기열에 넣을 수 있는 기능이 필요하므로 스케줄러에 작업을 주입할 수 있는 스레드 안전 방법이 필요합니다. 각 프로세서의 실행 대기열이 스레드 안전 푸시 작업(MPSC)을 지원하거나 각 프로세서에 동기화되지 않은 대기열과 스레드 안전 대기열의 두 가지 실행 대기열이 있습니다.

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

이것이 [씨스타](https://seastar.io/)가 사용하는 전략입니다. 동기화를 거의 완전히 피할 수 있기 때문에 이 전략은 매우 빠를 수 있습니다. 하지만 이 전략이 만병통치약은 아닙니다. 워크로드가 완전히 균일하지 않은 경우, 일부 프로세서는 유휴 상태가 되고 다른 프로세서는 부하가 걸려 리소스 활용도가 낮아집니다. 이는 작업이 특정 프로세서에 고정되어 있기 때문에 발생합니다. 단일 프로세서의 여러 작업이 일괄적으로 예약되어 있으면 다른 프로세서가 유휴 상태일지라도 해당 단일 프로세서가 급증하는 작업을 처리해야 합니다.

대부분의 "실제" 워크로드는 균일하지 않습니다. 이 때문에 범용 스케줄러는 이 모델을 피하는 경향이 있습니다.
