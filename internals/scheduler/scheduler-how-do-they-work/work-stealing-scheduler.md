# Work-stealing scheduler (작업을 훔치는 예약기)

작업 훔치기 스케줄러는 샤딩된 스케줄러 모델을 기반으로 하며 활용도 저하 문제를 해결합니다. 각 프로세서는 자체 실행 대기열을 유지합니다. 실행 가능한 작업이 되면 현재 프로세서의 실행 대기열로 푸시되고 프로세서는 로컬 실행 대기열을 비웁니다. 그러나 프로세서가 유휴 상태가 되면 형제 프로세서 실행 대기열을 확인하여 해당 프로세서의 실행 대기열을 훔치려고 시도합니다. 프로세서는 형제 실행 대기열에서 작업을 찾지 못한 경우에만 절전 모드로 전환됩니다.

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

모델 수준에서 이것은 "두 가지 장점을 모두 갖춘" 접근 방식입니다. 부하가 걸리면 프로세서가 독립적으로 작동하여 동기화 오버헤드를 피할 수 있습니다. 부하가 프로세서 간에 균등하게 분산되지 않는 경우 스케줄러가 재분배할 수 있습니다. 이러한 특성으로 인해 작업 훔치기 스케줄러는 Go, Erlang, Java 등에서 선택되고 있습니다.

단점은 이 접근 방식이 훨씬 더 복잡하다는 점입니다. 실행 대기열 알고리즘이 작업 훔치기 작업을 지원해야 하고 원활한 실행을 위해 프로세서 간 동기화가 필요하다는 점입니다. 올바르게 수행하지 않으면 작업 훔치기 모델을 구현하는 데 드는 오버헤드가 얻는 이점보다 더 클 수 있습니다.

이 경우를 생각해 보겠습니다: 프로세서 A는 현재 작업을 실행 중이며 실행 대기열이 비어 있습니다. 프로세서 B는 유휴 상태이며 작업을 훔치려다가 실패하여 절전 모드로 전환됩니다. 그런 다음 프로세서 A가 실행 중인 작업이 20개의 작업을 스폰합니다. 목표는 프로세서 B가 깨어나서 새로 생성된 작업 중 일부를 훔치는 것입니다. 이를 달성하기 위해 작업 훔치기 스케줄러는 프로세서가 대기열에서 새로운 작업을 발견하면 잠자는 형제 프로세서에 신호를 보내는 휴리스틱이 필요합니다. 물론 이렇게 하면 동기화가 추가로 발생하므로 이 작업을 최소화해야 합니다.

요약하자면:

* 동기화를 최소화하는 것이 좋습니다.&#x20;
* 작업 훔치기는 범용 스케줄러가 선택하는 알고리즘입니다.&#x20;
* 각 프로세서는 대부분 독립적이지만 훔치기를 위해서는 약간의 동기화가 필요합니다.

