# One queue, many processors (하나의 글로벌 실행 대기열, 많은 프로세서)

이 모델에서는 하나의 전역 실행 대기열이 있습니다. 작업을 실행할 수 있게 되면 해당 작업은 큐의 맨 끝으로 들어갑니다. 각각 별도의 스레드에서 실행되는 여러 프로세서가 있습니다. 각 프로세서는 대기열에서  꺼내서 실행하고, 없으면 멈춥니다.&#x20;

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

실행 대기열은 여러 생산자(Producer)와 여러 소비자(Consumer)를 모두 지원해야 합니다. 일반적으로 사용되는 알고리즘은 침입형 링크드 리스트(Intrusive Linked List)입니다. 침입형(Intrusive)이란 작업 구조가 작업을 링크된 목록 노드로 래핑하는 대신 실행 대기열의 다음 작업에 대한 포인터를 포함한다는 의미입니다. 이렇게 하면 넣고 빼는작업에 대한 할당을 피할 수 있습니다. 잠금 없는 (Lock free) 넣기 연산을 사용할 수 있지만 빼기을 사용하려면 소비자(Consumer)를 조정하기 위한 뮤텍스가 필요합니다.

이 접근 방식은 몇 가지 장점이 있기 때문에 범용 스레드 풀을 구현할 때 일반적으로 사용됩니다:

* 작업은 공정하게 예약됩니다.&#x20;
* 구현은 비교적 간단합니다. 제공된대기열을 위에 코드로 보인 프로세서 루프와 짝을 이루면 됩니다.

이 스케줄러 모델에는 단점이 있습니다. 모든 프로세서가 큐의 헤드를 차지하기 위해 경쟁합니다. 범용 스레드 풀의 경우, 이는 일반적으로 큰 문제가 되지 않습니다. 프로세서가 작업을 실행하는 데 소요되는 시간이 실행 대기열에서 작업을 꺼내는 데 소요되는 시간보다 훨씬 더 많기 때문입니다. 작업이 오랜 시간 동안 실행되면 큐 경합이 줄어듭니다. 그러나 Rust의 비동기 작업은 실행 대기열에서 팝될 때 실행하는 데 시간이 거의 걸리지 않을 것으로 예상됩니다. 이 시나리오에서는 큐 경합으로 인한 오버헤드가 상당히 커집니다.
