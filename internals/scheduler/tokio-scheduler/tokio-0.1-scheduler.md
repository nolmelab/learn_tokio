# tokio 0.1 scheduler

토키오는 2018년 3월에 작업 훔치기 스케줄러를 처음 출시했습니다. 이는 잘못된 것으로 판명된 몇 가지 가정을 기반으로 한 첫 시도였습니다.

첫째, Tokio 0.1 스케줄러는 일정 시간 동안 유휴 상태일 경우 프로세서 스레드를 종료해야 한다고 가정했습니다. 이 스케줄러는 원래 Rust 퓨처(Future)에 대한 "범용" 스레드 풀 실행기로 의도되었습니다. 스케줄러가 처음 작성되었을 때, 토키오는 아직 "토키오 코어" 시절이었습니다. 이 시점에서는 I/O 기반 작업이 I/O 선택기(epoll, kqueue, iocp, ...)와 함께 배치된 단일 스레드에서 실행되는 것이 모델이었습니다. 더 많은 CPU 바운드 작업은 스레드 풀에 할당될 수 있었습니다. 이러한 맥락에서 활성 스레드의 수는 유연해야 하며 유휴 스레드를 종료하는 것이 더 합리적입니다. 그러나 이 모델은 작업 훔치기 스케줄러에서 모든 비동기 작업을 실행하는 것으로 전환되었으며, 이 경우 적은 수의 스레드를 항상 활성 상태로 유지하는 것이 더 합리적입니다.

둘째, 크로스빔 데크(deque) 구현을 사용했습니다. 이 구현은 아래에 설명된 이유로 독립적인 비동기 작업을 예약하는 사용 사례에는 적합하지 않은 체이스-레브 덱(Chase-Lev deque)을 기반으로 합니다.

셋째, 구현이 지나치게 복잡합니다. 이는 부분적으로는 제가 처음으로 스케줄러를 구현했기 때문입니다. 또한 뮤텍스로도 충분했을 코드 경로에 atomic를 사용하는 데 지나치게 열심이었기 때문입니다. 여기서 얻은 중요한 교훈은 뮤텍스가 최선의 선택인 경우가 많다는 것입니다.

마지막으로, 원래 구현에는 작은 비효율성이 많이 포함되어 있었습니다. Rust의 비동기 모델의 세부 사항은 초창기에 크게 발전했지만, 라이브러리는 그 기간 동안 API 안정성을 유지했습니다. 그 결과 약간의 부채가 누적되었지만 지금은 갚을 수 있게 되었습니다.

토키오의 첫 번째 주요 릴리스가 다가옴에 따라, 우리는 그 동안 배운 교훈으로 그 모든 빚을 갚을 수 있습니다. 정말 흥미로운 시기입니다!



